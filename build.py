# build.py - Chrono Build System (Dependency Aware)
import os
import sys
import json
import subprocess
import argparse

# --- 配置 ---
CONFIG_FILE_NAME = "config.json"
PYTHON_EXE = "python3"
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

# 防止循环依赖的已访问集合
visited_projects = set()


def print_color(text, color_code):
    """32=Green, 31=Red, 33=Yellow, 36=Cyan"""
    print(f"\033[{color_code}m{text}\033[0m")


def load_config(project_dir):
    config_path = os.path.join(project_dir, CONFIG_FILE_NAME)
    if not os.path.exists(config_path):
        return None

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print_color(f"Error parsing {config_path}: {e}", 31)
        sys.exit(1)


def generate_cmake_deps(config, project_dir):
    """
    根据 config.json 中的 dependencies 生成 cmake_deps.cmake
    """
    deps = config.get("dependencies", {})

    # 准备输出内容
    cmake_lines = [
        "# Auto-generated by build.py. DO NOT EDIT.",
        "# This file handles add_subdirectory and dependency linking.",
        ""
    ]

    lib_names = []

    for name, info in deps.items():
        # 目前只支持本地路径依赖
        if "path" in info:
            # 1. 处理路径 (Windows -> CMake Forward Slash)
            raw_path = info["path"]

            # 2. 生成 add_subdirectory
            # 参数1: 源码路径 (相对于当前 CMakeLists.txt)
            # 参数2: 二进制输出目录 (防止命名冲突，加个 _build 后缀)
            # 注意：我们将路径标准化为 / 以兼容 CMake
            cmake_path = raw_path.replace("\\", "/")
            cmake_lines.append(f'add_subdirectory("{cmake_path}" {name}_build)')

            lib_names.append(name)

    # 3. 定义 CHRONO_LIBS 变量供主项目链接
    libs_string = " ".join(lib_names)
    cmake_lines.append(f'\nset(CHRONO_LIBS {libs_string})')

    # 4. 写入 build/cmake_deps.cmake
    build_dir = os.path.join(project_dir, "build")
    os.makedirs(build_dir, exist_ok=True)

    out_path = os.path.join(build_dir, "cmake_deps.cmake")
    with open(out_path, "w", encoding='utf-8') as f:
        f.write("\n".join(cmake_lines))

    print_color(f"  [CMake] Generated dependency file: build/cmake_deps.cmake", 36)


def transpile_file(transpiler_path, input_path, output_path):
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    cmd = [PYTHON_EXE, transpiler_path, input_path, output_path]

    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True, encoding='utf-8')
        if "NO OK!" in result.stdout or "NO OK!" in result.stderr:
            raise subprocess.CalledProcessError(1, cmd, result.stdout, result.stderr)
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"STDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}"


def process_project(project_dir, is_root=False):
    """
    递归处理项目：
    1. 检查并构建依赖
    2. 生成 CMake 依赖文件
    3. 转译当前项目源码
    """
    abs_path = os.path.abspath(project_dir)

    # 1. 循环依赖检查
    if abs_path in visited_projects:
        return True
    visited_projects.add(abs_path)

    config = load_config(abs_path)
    if not config:
        print_color(f"Skipping {project_dir} (No {CONFIG_FILE_NAME})", 33)
        return False

    pkg_name = config.get("package_name", os.path.basename(abs_path))
    print_color(f"\n=== Processing Package: {pkg_name} ===", 32)

    # 2. [递归] 优先构建依赖
    deps = config.get("dependencies", {})
    if deps:
        print(f"  Checking dependencies: {', '.join(deps.keys())}...")
        for dep_name, dep_info in deps.items():
            if "path" in dep_info:
                # 计算依赖的绝对路径
                dep_path = os.path.normpath(os.path.join(abs_path, dep_info["path"]))
                if not process_project(dep_path):
                    print_color(f"Dependency failed: {dep_name}", 31)
                    return False

    # 3. [生成] 为当前项目生成 CMake 依赖文件
    # (只有当这是根项目，或者它有依赖时才需要，但生成一下无妨)
    generate_cmake_deps(config, abs_path)

    # 4. [转译] 处理当前项目的源码
    # 定位转译器
    raw_script_path = config.get("transpiler_script", "src/transpiler.py")
    # 尝试相对于项目路径
    transpiler_path = os.path.normpath(os.path.join(abs_path, raw_script_path))
    # 如果找不到，尝试相对于脚本所在目录(根目录)
    if not os.path.exists(transpiler_path):
        transpiler_path = os.path.join(SCRIPT_DIR, raw_script_path)

    if not os.path.exists(transpiler_path):
        print_color(f"Error: Transpiler not found at {transpiler_path}", 31)
        return False

    rules = config.get("build_rules", [])
    success_count = 0

    for rule in rules:
        src_root = rule.get("source_dir")
        out_root = rule.get("output_dir")

        if not src_root or not out_root: continue

        abs_src = os.path.join(abs_path, src_root)
        abs_out = os.path.join(abs_path, out_root)

        if not os.path.exists(abs_src): continue

        for root, dirs, files in os.walk(abs_src):
            for file in files:
                if not file.endswith(".ch"): continue

                in_file = os.path.join(root, file)
                rel_path = os.path.relpath(in_file, abs_src)

                # 映射后缀
                out_name = file
                if file.endswith(".h.ch"):
                    out_name = file[:-3]
                elif file.endswith(".cpp.ch"):
                    out_name = file[:-3]
                elif file.endswith(".ch"):
                    out_name = file[:-3] + ".cpp"

                out_file = os.path.join(abs_out, os.path.dirname(rel_path), out_name)

                print(f"  [Transpile] {rel_path} -> {out_name}")
                ok, msg = transpile_file(transpiler_path, in_file, out_file)
                if not ok:
                    print_color(f"  [FAIL] {file}\n{msg}", 31)
                    return False
                success_count += 1

    print(f"  -> Built {pkg_name} ({success_count} files)")
    return True


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command', required=True)

    cmd_transpile = subparsers.add_parser('transpile')
    cmd_transpile.add_argument('-d', '--directory', required=True)

    args = parser.parse_args()

    if args.command == 'transpile':
        target_dir = os.path.abspath(args.directory)
        if process_project(target_dir, is_root=True):
            print_color("\n=== Build Chain Complete Successfully ===", 32)
        else:
            print_color("\n=== Build Chain Failed ===", 31)
            sys.exit(1)


if __name__ == "__main__":
    main()