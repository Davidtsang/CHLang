# build.py - Chrono Build System (Dependency Aware & Two-Phase & Smart Incremental)
import os
import sys
import json
import subprocess
import argparse

# --- 配置 ---
CONFIG_FILE_NAME = "config.json"
PYTHON_EXE = "python3"
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

# 防止循环依赖的已访问集合
visited_projects = set()


def clean_stale_files(output_dirs, expected_files):
    """清理输出目录中不属于本次构建的文件"""
    cleaned_count = 0
    for out_dir in output_dirs:
        if not os.path.exists(out_dir): continue

        for root, _, files in os.walk(out_dir):
            for file in files:
                # 只清理构建产物
                if not (file.endswith(".cpp") or file.endswith(".h") or file.endswith(".json")):
                    continue

                full_path = os.path.abspath(os.path.join(root, file))

                # 如果这个文件不在我们的期望列表中，它就是废弃的
                if full_path not in expected_files:
                    try:
                        os.remove(full_path)
                        # print(f"  [Clean] Removed stale file: {file}")
                        cleaned_count += 1
                    except OSError as e:
                        print_color(f"  [Warn] Failed to remove {file}: {e}", 33)

    if cleaned_count > 0:
        print(f"  -> Cleaned {cleaned_count} stale files.")

def get_mtime(path):
    """获取文件修改时间，文件不存在返回 0"""
    return os.path.getmtime(path) if os.path.exists(path) else 0


def print_color(text, color_code):
    """32=Green, 31=Red, 33=Yellow, 36=Cyan"""
    print(f"\033[{color_code}m{text}\033[0m")


def load_config(project_dir):
    config_path = os.path.join(project_dir, CONFIG_FILE_NAME)
    if not os.path.exists(config_path):
        return None

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print_color(f"Error parsing {config_path}: {e}", 31)
        sys.exit(1)


def generate_cmake_deps(config, project_dir):
    deps = config.get("dependencies", {})
    cmake_lines = [
        "# Auto-generated by build.py. DO NOT EDIT.",
        "# This file handles add_subdirectory and dependency linking.",
        ""
    ]
    lib_names = []

    for name, info in deps.items():
        if "path" in info:
            raw_path = info["path"]
            cmake_path = raw_path.replace("\\", "/")
            cmake_lines.append(f'add_subdirectory("{cmake_path}" {name}_build)')
            lib_names.append(name)

    libs_string = " ".join(lib_names)
    cmake_lines.append(f'\nset(CHRONO_LIBS {libs_string})')

    build_dir = os.path.join(project_dir, "build")
    os.makedirs(build_dir, exist_ok=True)

    out_path = os.path.join(build_dir, "cmake_deps.cmake")
    with open(out_path, "w", encoding='utf-8') as f:
        f.write("\n".join(cmake_lines))

    print_color(f"  [CMake] Generated dependency file: build/cmake_deps.cmake", 36)


# [关键修改点] 必须传递 dep_file
def run_transpiler_cmd(transpiler_path, input_path, output_path, current_symbols=None, dep_symbols=None):
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # 1. 计算依赖文件路径
    dep_file = output_path + ".dep.json"

    # 2. 构造命令：增加 dep_file 参数
    cmd = [PYTHON_EXE, transpiler_path, input_path, output_path, dep_file]

    if current_symbols:
        cmd.append("--symbols")
        cmd.append(current_symbols)

    if dep_symbols and len(dep_symbols) > 0:
        cmd.append("--deps")
        cmd.extend(dep_symbols)

    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True, encoding='utf-8')
        if "NO OK!" in result.stdout or "NO OK!" in result.stderr:
            raise subprocess.CalledProcessError(1, cmd, result.stdout, result.stderr)
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"STDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}"


def process_project(project_dir, is_root=False):
    """
    递归处理项目：
    1. 递归构建依赖，并收集它们的符号表路径。
    2. 确定当前项目的符号表路径。
    3. 执行双阶段编译 (Headers First -> Sources)。
    """
    abs_path = os.path.abspath(project_dir)

    # 1. 循环依赖检查
    if abs_path in visited_projects:
        return True
    visited_projects.add(abs_path)

    config = load_config(abs_path)
    if not config:
        print_color(f"Skipping {project_dir} (No {CONFIG_FILE_NAME})", 33)
        return False

    pkg_name = config.get("package_name", os.path.basename(abs_path))
    print_color(f"\n=== Processing Package: {pkg_name} ===", 32)

    # ============================================================
    # 2. 依赖处理 (保持不变)
    # ============================================================
    dep_symbol_files = []
    deps = config.get("dependencies", {})
    if deps:
        print(f"  Checking dependencies: {', '.join(deps.keys())}...")
        for dep_name, dep_info in deps.items():
            if "path" in dep_info:
                dep_rel_path = dep_info["path"]
                dep_abs_path = os.path.normpath(os.path.join(abs_path, dep_rel_path))
                if not process_project(dep_abs_path):
                    print_color(f"Dependency failed: {dep_name}", 31)
                    return False

                dep_sym_path = os.path.join(dep_abs_path, "build", "dist", "symbols.json")
                if os.path.exists(dep_sym_path):
                    dep_symbol_files.append(dep_sym_path)
                else:
                    print_color(f"  [Warn] No symbols found for {dep_name}", 33)

    # 3. CMake (保持不变)
    generate_cmake_deps(config, abs_path)

    # 4. 准备任务
    raw_script_path = config.get("transpiler_script", "src/transpiler.py")
    transpiler_path = os.path.normpath(os.path.join(abs_path, raw_script_path))
    if not os.path.exists(transpiler_path):
        transpiler_path = os.path.join(SCRIPT_DIR, raw_script_path)
    if not os.path.exists(transpiler_path):
        print_color(f"Error: Transpiler not found at {transpiler_path}", 31)
        return False

    current_symbol_file = os.path.join(abs_path, "build", "dist", "symbols.json")
    headers_queue = []
    sources_queue = []

    # [新增] 跟踪所有预期的输出文件和目录
    expected_outputs = set()
    output_dirs_to_clean = set()

    # 总是保留 symbols.json
    expected_outputs.add(os.path.abspath(current_symbol_file))

    skipped_count = 0
    total_files = 0

    rules = config.get("build_rules", [])
    for rule in rules:
        src_root = rule.get("source_dir")
        out_root = rule.get("output_dir")
        if not src_root or not out_root: continue

        abs_src = os.path.join(abs_path, src_root)
        abs_out = os.path.join(abs_path, out_root)

        # 记录输出目录，稍后用于清理
        output_dirs_to_clean.add(os.path.abspath(abs_out))

        if not os.path.exists(abs_src): continue

        for root, dirs, files in os.walk(abs_src):
            for file in files:
                if not file.endswith(".ch"): continue
                in_file = os.path.join(root, file)
                rel_path = os.path.relpath(in_file, abs_src)

                out_name = file
                if file.endswith(".h.ch"):
                    out_name = file[:-3]
                elif file.endswith(".cpp.ch"):
                    out_name = file[:-3]
                elif file.endswith(".ch"):
                    out_name = file[:-3] + ".cpp"

                out_file = os.path.join(abs_out, os.path.dirname(rel_path), out_name)
                dep_file = out_file + ".dep.json"

                # ==================================================
                # [核心修复 1] 先加入白名单 (Expected Outputs)
                # ==================================================
                # 无论是否跳过编译，这个文件都是我们“期望存在”的
                # 如果不加这行，clean_stale_files 会把没改动的文件删掉！
                expected_outputs.add(os.path.abspath(out_file))
                expected_outputs.add(os.path.abspath(dep_file))

                # ==================================================
                # [核心修复 2] 再检查是否需要跳过 (增量逻辑)
                # ==================================================
                if os.path.exists(out_file) and get_mtime(in_file) <= get_mtime(out_file):
                    skipped_count += 1
                    # 这里 continue 是安全的，因为已经加到 expected_outputs 了
                    continue

                task = (in_file, out_file, rel_path)
                if file.endswith(".h.ch") or "include" in src_root:
                    headers_queue.append(task)
                else:
                    sources_queue.append(task)

                total_files += 1

    # [核心修复 3] 清理工作必须在所有规则遍历完之后进行
    clean_stale_files(output_dirs_to_clean, expected_outputs)

    # 注意：不要在这里重置 skipped_count，否则最后的统计就不对了

    # 5. 执行 Phase 1
    if headers_queue:
        print_color(f"  [Phase 1] Compiling {len(headers_queue)} Headers...", 36)
        for in_file, out_file, rel_path in headers_queue:
            print(f"    {rel_path}")
            ok, msg = run_transpiler_cmd(transpiler_path, in_file, out_file, current_symbol_file, dep_symbol_files)
            if not ok:
                print_color(f"  [FAIL] {rel_path}\n{msg}", 31)
                return False

    # 6. 执行 Phase 2
    if sources_queue:
        print_color(f"  [Phase 2] Compiling {len(sources_queue)} Sources...", 36)
        for in_file, out_file, rel_path in sources_queue:
            print(f"    {rel_path}")
            ok, msg = run_transpiler_cmd(transpiler_path, in_file, out_file, current_symbol_file, dep_symbol_files)
            if not ok:
                print_color(f"  [FAIL] {rel_path}\n{msg}", 31)
                return False

    # 统计总数 (编译的 + 跳过的)
    total_processed = len(headers_queue) + len(sources_queue) + skipped_count
    print(f"  -> {pkg_name}: Processed {total_processed} files (Skipped {skipped_count})")
    return True



def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command', required=True)
    cmd_transpile = subparsers.add_parser('transpile')
    cmd_transpile.add_argument('-d', '--directory', required=True)

    args = parser.parse_args()

    if args.command == 'transpile':
        target_dir = os.path.abspath(args.directory)
        if process_project(target_dir, is_root=True):
            print_color("\n=== Build Chain Complete Successfully ===", 32)
        else:
            print_color("\n=== Build Chain Failed ===", 31)
            sys.exit(1)


if __name__ == "__main__":
    main()