
    def visitClassDefinition(self, ctx: ChronoParser.ClassDefinitionContext):
        class_name = ctx.name.text

        # [ 关键修复 ] 检查 base class 是否存在
        base_name_str = ""
        if ctx.base:
            # 如果存在基类 (e.g., : ChronoObject)
            base_name = ctx.base.text
            base_name_str = f" : public {base_name}" # 假设所有继承都是 public

        # --- (Class Assembler 逻辑保持不变) ---
        self._in_class = True
        self._current_class_name = class_name
        self._class_sections = {"private": "", "public": ""}

        if hasattr(ctx, 'classBodyStatement'):
            for child in ctx.classBodyStatement():
                self.visit(child)  # <--- 这将调用 visitClassBodyStatement

        self._in_class = False
        self._current_class_name = None

        final_class_body = ""

        # 1. 输出 private (默认)
        if self._class_sections["private"]:
            final_class_body += "\nprivate:\n"
            final_class_body += self._class_sections["private"]
        if self._class_sections["public"]:
            final_class_body += "\npublic:\n"
            final_class_body += self._class_sections["public"]
        # --- (Class Assembler 逻辑结束) ---

        # [ 关键修复 ] 使用 base_name_str 变量
        return (
            f"\nclass {class_name}{base_name_str} {{\n" # <-- 动态添加继承
            f"{final_class_body.strip()}\n"
            "};\n"
        )