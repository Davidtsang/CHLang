# build.py - Chrono Build System (Dependency Aware & Two-Phase)
import os
import sys
import json
import subprocess
import argparse

# --- 配置 ---
CONFIG_FILE_NAME = "config.json"
PYTHON_EXE = "python3"
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

# 防止循环依赖的已访问集合
visited_projects = set()

def print_color(text, color_code):
    """32=Green, 31=Red, 33=Yellow, 36=Cyan"""
    print(f"\033[{color_code}m{text}\033[0m")

def load_config(project_dir):
    config_path = os.path.join(project_dir, CONFIG_FILE_NAME)
    if not os.path.exists(config_path):
        return None

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print_color(f"Error parsing {config_path}: {e}", 31)
        sys.exit(1)

def generate_cmake_deps(config, project_dir):
    """
    根据 config.json 中的 dependencies 生成 cmake_deps.cmake
    """
    deps = config.get("dependencies", {})
    cmake_lines = [
        "# Auto-generated by build.py. DO NOT EDIT.",
        "# This file handles add_subdirectory and dependency linking.",
        ""
    ]
    lib_names = []

    for name, info in deps.items():
        if "path" in info:
            raw_path = info["path"]
            cmake_path = raw_path.replace("\\", "/")
            cmake_lines.append(f'add_subdirectory("{cmake_path}" {name}_build)')
            lib_names.append(name)

    libs_string = " ".join(lib_names)
    cmake_lines.append(f'\nset(CHRONO_LIBS {libs_string})')

    build_dir = os.path.join(project_dir, "build")
    os.makedirs(build_dir, exist_ok=True)

    out_path = os.path.join(build_dir, "cmake_deps.cmake")
    with open(out_path, "w", encoding='utf-8') as f:
        f.write("\n".join(cmake_lines))

    print_color(f"  [CMake] Generated dependency file: build/cmake_deps.cmake", 36)

def run_transpiler_cmd(transpiler_path, input_path, output_path, current_symbols=None, dep_symbols=None):
    """
    调用 transpiler.py，传递符号表参数
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    cmd = [PYTHON_EXE, transpiler_path, input_path, output_path]

    # 传递当前项目的符号表 (读+写)
    if current_symbols:
        cmd.append("--symbols")
        cmd.append(current_symbols)

    # 传递依赖项目的符号表 (只读)
    if dep_symbols and len(dep_symbols) > 0:
        cmd.append("--deps")
        cmd.extend(dep_symbols)

    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True, encoding='utf-8')
        # 双重检查输出内容
        if "NO OK!" in result.stdout or "NO OK!" in result.stderr:
            raise subprocess.CalledProcessError(1, cmd, result.stdout, result.stderr)
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"STDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}"

def process_project(project_dir, is_root=False):
    """
    递归处理项目：
    1. 递归构建依赖，并收集它们的符号表路径。
    2. 确定当前项目的符号表路径。
    3. 执行双阶段编译 (Headers First -> Sources)。
    """
    abs_path = os.path.abspath(project_dir)

    # 1. 循环依赖检查
    if abs_path in visited_projects:
        return True
    visited_projects.add(abs_path)

    config = load_config(abs_path)
    if not config:
        print_color(f"Skipping {project_dir} (No {CONFIG_FILE_NAME})", 33)
        return False

    pkg_name = config.get("package_name", os.path.basename(abs_path))
    print_color(f"\n=== Processing Package: {pkg_name} ===", 32)

    # ============================================================
    # 2. 处理依赖 & 收集依赖符号表
    # ============================================================
    dep_symbol_files = []

    deps = config.get("dependencies", {})
    if deps:
        print(f"  Checking dependencies: {', '.join(deps.keys())}...")
        for dep_name, dep_info in deps.items():
            if "path" in dep_info:
                dep_rel_path = dep_info["path"]
                dep_abs_path = os.path.normpath(os.path.join(abs_path, dep_rel_path))

                # 递归构建依赖
                if not process_project(dep_abs_path):
                    print_color(f"Dependency failed: {dep_name}", 31)
                    return False

                # 收集该依赖产生的符号表
                # 规范: build/dist/symbols.json
                dep_sym_path = os.path.join(dep_abs_path, "build", "dist", "symbols.json")
                if os.path.exists(dep_sym_path):
                    dep_symbol_files.append(dep_sym_path)
                    # print(f"  [Link] Found symbols: {dep_name}")
                else:
                    print_color(f"  [Warn] No symbols found for {dep_name}", 33)

    # 3. 生成 CMake 依赖文件
    generate_cmake_deps(config, abs_path)

    # ============================================================
    # 4. 准备当前项目的编译任务
    # ============================================================

    # 定位转译器
    raw_script_path = config.get("transpiler_script", "src/transpiler.py")
    transpiler_path = os.path.normpath(os.path.join(abs_path, raw_script_path))
    if not os.path.exists(transpiler_path):
        transpiler_path = os.path.join(SCRIPT_DIR, raw_script_path)

    if not os.path.exists(transpiler_path):
        print_color(f"Error: Transpiler not found at {transpiler_path}", 31)
        return False

    # 定义当前项目符号表输出路径
    current_symbol_file = os.path.join(abs_path, "build", "dist", "symbols.json")

    # 扫描文件并分类
    headers_queue = [] # Phase 1
    sources_queue = [] # Phase 2

    rules = config.get("build_rules", [])
    total_files = 0

    for rule in rules:
        src_root = rule.get("source_dir")
        out_root = rule.get("output_dir")
        if not src_root or not out_root: continue

        abs_src = os.path.join(abs_path, src_root)
        abs_out = os.path.join(abs_path, out_root)

        if not os.path.exists(abs_src): continue

        for root, dirs, files in os.walk(abs_src):
            for file in files:
                if not file.endswith(".ch"): continue

                in_file = os.path.join(root, file)
                rel_path = os.path.relpath(in_file, abs_src)

                # 计算输出文件名
                out_name = file
                if file.endswith(".h.ch"):
                    out_name = file[:-3]
                elif file.endswith(".cpp.ch"):
                    out_name = file[:-3]
                elif file.endswith(".ch"):
                    out_name = file[:-3] + ".cpp"

                out_file = os.path.join(abs_out, os.path.dirname(rel_path), out_name)

                task = (in_file, out_file, rel_path)

                # 分类逻辑:
                # .h.ch 或者位于 include 目录下的文件归为 Headers
                if file.endswith(".h.ch") or "include" in src_root:
                    headers_queue.append(task)
                else:
                    sources_queue.append(task)

                total_files += 1

    # ============================================================
    # 5. 执行 Phase 1: 编译头文件 (收集符号)
    # ============================================================
    if headers_queue:
        print_color("  [Phase 1] Compiling Headers & Building Symbols...", 36)
        for in_file, out_file, rel_path in headers_queue:
            print(f"    {rel_path}")
            ok, msg = run_transpiler_cmd(
                transpiler_path, in_file, out_file,
                current_symbol_file, dep_symbol_files
            )
            if not ok:
                print_color(f"  [FAIL] {rel_path}\n{msg}", 31)
                return False

    # ============================================================
    # 6. 执行 Phase 2: 编译源文件 (使用符号生成反射代码)
    # ============================================================
    if sources_queue:
        print_color("  [Phase 2] Compiling Sources...", 36)
        for in_file, out_file, rel_path in sources_queue:
            print(f"    {rel_path}")
            ok, msg = run_transpiler_cmd(
                transpiler_path, in_file, out_file,
                current_symbol_file, dep_symbol_files
            )
            if not ok:
                print_color(f"  [FAIL] {rel_path}\n{msg}", 31)
                return False

    print(f"  -> Built {pkg_name} ({total_files} files)")
    return True

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command', required=True)

    cmd_transpile = subparsers.add_parser('transpile')
    cmd_transpile.add_argument('-d', '--directory', required=True)

    args = parser.parse_args()

    if args.command == 'transpile':
        target_dir = os.path.abspath(args.directory)
        if process_project(target_dir, is_root=True):
            print_color("\n=== Build Chain Complete Successfully ===", 32)
        else:
            print_color("\n=== Build Chain Failed ===", 31)
            sys.exit(1)

if __name__ == "__main__":
    main()