# src/ChronoVisitor.py

from antlr4 import *
from parser.ChronoParser import ChronoParser
from parser.ChronoParserVisitor import ChronoParserVisitor as BaseChronoVisitor

INDENT = "    " 

class ChronoVisitor(BaseChronoVisitor):

    def __init__(self):
        super().__init__()
        self._in_class = False
        self._current_class_name = None

    # --- 辅助函数 ---
    def _chrono_to_cpp_type(self, chrono_type_name):
        if chrono_type_name == "int" or chrono_type_name == "i32":
            return "int32_t"
        if chrono_type_name == "i64":
            return "int64_t"
        if chrono_type_name == "String":
            return "ChronoString"
        if chrono_type_name == "Int":
            return "ChronoInt"
        return chrono_type_name

    # --- 顶层规则 ---
    def visitProgram(self, ctx: ChronoParser.ProgramContext):
        globals_code = "".join(self.visit(g) for g in ctx.globalStatement())
        
        definitions_code = ""
        for child in ctx.children:
            if isinstance(child, (ChronoParser.ClassDefinitionContext, 
                                 ChronoParser.FunctionDefinitionContext)):
                definitions_code += self.visit(child)
        
        main_wrapper = (
            "\n// C++ 程序的标准入口\n"
            "int main() {\n"
            f"{INDENT}return Chrono_main();\n"
            "}\n"
        )
        return globals_code + definitions_code + main_wrapper

    def visitImportDirective(self, ctx: ChronoParser.ImportDirectiveContext):
        path_text = ctx.path.text
        if path_text.startswith('<'):
            return f"#include {path_text}\n"
        elif path_text.startswith('"'):
            path_content = path_text[1:-1] 
            if path_content.startswith('runtime/'):
                path_content = path_content.replace('runtime/', '')
            return f'#include "{path_content}"\n'
        return f"// ERROR: Invalid import path {path_text}\n"

    def visitClassDefinition(self, ctx: ChronoParser.ClassDefinitionContext):
        class_name = ctx.name.text
        base_name = ctx.base.text
        
        self._in_class = True
        self._current_class_name = class_name
        
        body_code = ""
        for decl in ctx.declaration():
            body_code += self.visit(decl)
        for func in ctx.functionDefinition():
            body_code += self.visit(func)
        for deinit in ctx.deinitBlock():
            body_code += self.visit(deinit)
            
        self._in_class = False
        self._current_class_name = None
        
        return (
            f"\nclass {class_name} : public {base_name} {{\n"
            "public:\n"
            f"{body_code}"
            "};\n"
        )
    
    def visitDeinitBlock(self, ctx: ChronoParser.DeinitBlockContext):
        body_code = "".join(self.visit(s) for s in ctx.statement())
        return (
            f"\n{INDENT}virtual ~{self._current_class_name}() {{\n"
            f"{INDENT}// --- Chrono Deinit Block ---\n"
            f"{body_code}"
            f"{INDENT}// --- Deinit End ---\n"
            f"{INDENT}}}\n"
        )

    def visitFunctionDefinition(self, ctx: ChronoParser.FunctionDefinitionContext):
        func_name = ctx.name.text
        return_type = ctx.returnType.text
        params_code = self.visit(ctx.parameters()) if ctx.parameters() else ""
        body_code = "".join(self.visit(s) for s in ctx.statement())
        
        cpp_return_type = ""
        cpp_func_name = ""
        
        if func_name == "main" and return_type == "Int":
            cpp_return_type = "int"
            cpp_func_name = "Chrono_main"
        else:
            if return_type in ("i32", "i64", "int"):
                cpp_return_type = self._chrono_to_cpp_type(return_type)
            else:
                cpp_return_type = f"{self._chrono_to_cpp_type(return_type)}*"
            
            if func_name == "init":
                cpp_return_type = "" 
                cpp_func_name = self._current_class_name
            else:
                cpp_func_name = func_name
        
        indent = INDENT*2 if self._in_class else INDENT
        
        if self._in_class:
             return (
                f"\n{INDENT}{cpp_return_type} {cpp_func_name}({params_code}) {{\n"
                f"{indent}// --- Chrono Method Body: {func_name} ---\n"
                f"{body_code.replace(INDENT, indent)}"
                f"{indent}// --- Method End ---\n"
                f"{INDENT}}}\n"
            )
        else:
             return (
                f"\n{cpp_return_type} {cpp_func_name}({params_code}) {{\n"
                f"{INDENT}// --- Chrono Function Body: {func_name} ---\n"
                f"{body_code}"
                f"{INDENT}// --- Function End ---\n"
                "}\n"
            )
            
    def visitParameters(self, ctx: ChronoParser.ParametersContext):
        params_list = []
        for p in ctx.parameter():
            params_list.append(self.visit(p))
        return ", ".join(params_list)

    def visitParameter(self, ctx: ChronoParser.ParameterContext):
        name = ctx.name.text
        type_name = ctx.typeName.text
        
        if type_name in ("i32", "i64", "int"):
            cpp_type = self._chrono_to_cpp_type(type_name)
            return f"{cpp_type} {name}"
        else:
            cpp_type = f"{self._chrono_to_cpp_type(type_name)}*"
            return f"{cpp_type} {name}"

    # --- 语句 ---
    def visitStatement(self, ctx: ChronoParser.StatementContext):
        if ctx.declaration():
            return self.visit(ctx.declaration())
        if ctx.assignment():
            return self.visit(ctx.assignment())
        if ctx.returnStatement():
            return self.visit(ctx.returnStatement())
        if ctx.cppBlock():
            return self.visit(ctx.cppBlock())
        
        if ctx.expression():
            expr_code = self.visit(ctx.expression())
            return f"{INDENT}{expr_code};\n"
            
        return ""

    def visitDeclaration(self, ctx: ChronoParser.DeclarationContext):
        var_name = ctx.variableName.text
        type_name = ctx.typeName.text
        
        cpp_type = ""
        
        if type_name in ("i32", "i64", "int"):
            cpp_type = self._chrono_to_cpp_type(type_name)
            if self._in_class:
                return f"{INDENT}{cpp_type} {var_name};\n"
            else:
                cpp_value = "0"
                if ctx.expression():
                    cpp_value = self.visit(ctx.expression())
                return f"{INDENT}const {cpp_type} {var_name} = {cpp_value};\n"
        else:
            cpp_class_name = self._chrono_to_cpp_type(type_name)
            cpp_type = f"{cpp_class_name}*"
            
            if self._in_class:
                return f"{INDENT}{cpp_type} {var_name};\n"
            else:
                cpp_value = "nullptr"
                if ctx.expression():
                    expression_code = self.visit(ctx.expression())
                    expression_node = ctx.expression()
                    
                    if expression_node.methodCallExpression() or \
                       expression_node.functionCallExpression() or \
                       expression_node.IDENTIFIER() or \
                       (expression_node.THIS() and expression_node.IDENTIFIER()):
                        cpp_value = expression_code
                    elif expression_node.literal():
                        cpp_value = f"{cpp_class_name}::create({expression_code})"
                
                return f"{INDENT}{cpp_type} const {var_name} = {cpp_value};\n"

    def visitReturnStatement(self, ctx: ChronoParser.ReturnStatementContext):
        return_value = self.visit(ctx.expression())
        return f"{INDENT}return {return_value};\n"

    def visitCppBlock(self, ctx: ChronoParser.CppBlockContext):
        token_list = ctx.CPP_BODY()
        if token_list is None: token_list = []
        raw_cpp = "".join(token.getText() for token in token_list)
        return (
            f"\n{INDENT}// --- @cpp Block Start ---\n"
            f"{raw_cpp.strip()}\n" 
            f"{INDENT}// --- @cpp Block End ---\n\n"
        )
        
    def visitAssignment(self, ctx: ChronoParser.AssignmentContext):
        target_node = ctx.getChild(0)
        target = ""
        if target_node.THIS():
            target = f"this->{target_node.IDENTIFIER().getText()}"
        else:
            target = target_node.getText()
        value = self.visit(ctx.expression())
        return f"{INDENT}{target} = {value};\n"

    # --- 表达式 ---
    def visitExpression(self, ctx: ChronoParser.ExpressionContext):
        if ctx.literal():
            return self.visit(ctx.literal())
        if ctx.IDENTIFIER():
            return ctx.IDENTIFIER().getText()
        if ctx.methodCallExpression():
            return self.visit(ctx.methodCallExpression())
        if ctx.functionCallExpression():
            return self.visit(ctx.functionCallExpression())
        if ctx.THIS():
            return f"this->{ctx.IDENTIFIER().getText()}"
        raise Exception(f"Unknown expression type at line {ctx.start.line}")

    # [ Bug 3 已修正 ]
    def visitMethodCallExpression(self, ctx: ChronoParser.MethodCallExpressionContext):
        # 'ctx.receiver' 是一个 CommonToken
        receiver_token = ctx.receiver 
        receiver = ""
        
        # 修正: 直接访问 '.type' 属性
        if receiver_token.type == ChronoParser.THIS:
            receiver = "this"
        else:
            # 它是 IDENTIFIER
            receiver = receiver_token.text
            
        method = ctx.methodName.text
        args = ""
        if ctx.expressionList():
            args = self.visit(ctx.expressionList())
            
        return f"{receiver}->{method}({args})"

    def visitExpressionList(self, ctx: ChronoParser.ExpressionListContext):
        return ", ".join(self.visit(e) for e in ctx.expression())

    def visitLiteral(self, ctx: ChronoParser.LiteralContext):
        return ctx.getText()
        
    def visitFunctionCallExpression(self, ctx: ChronoParser.FunctionCallExpressionContext):
        func_name = ctx.name.text
        
        args_code = ""
        if ctx.expressionList():
            args_code = self.visit(ctx.expressionList())

        if func_name == "print":
            arg_expression = ctx.expressionList().expression(0)
            arg_code = self.visit(arg_expression)
            
            cpp_value = ""
            # 检查表达式是否是字面量
            if arg_expression.literal():
                if arg_expression.literal().STRING_LITERAL():
                    cpp_value = f"ChronoString::create({arg_code})"
                elif arg_expression.literal().INTEGER_LITERAL():
                    cpp_value = f"ChronoInt::create({arg_code})"
            else:
                # 已经是 T* 或 i32
                cpp_value = arg_code
            
            return f"Print({cpp_value})"

        else:
            # C++ 宏或全局函数
            return f"{func_name}({args_code})"