# src/CHVisitor.py
import os
from CompileContext import CompileContext

from parser.CHParser import CHParser
from parser.CHParserVisitor import CHParserVisitor as BaseCHVisitor
from antlr4.tree.Tree import TerminalNodeImpl

INDENT = "    "

class CHVisitor(BaseCHVisitor):

    def __init__(self, context: CompileContext = None, import_loader_callback=None):
        super().__init__()
        self.context = context if context else CompileContext()
        self.import_loader_callback = import_loader_callback

        self._in_class_method = False
        self._in_class = False
        self._in_struct = False
        self._current_class_name = None
        self._class_sections = {"private": "", "public": ""}
        self._alias_to_namespace_map = {}
        self._scope_stack = [{}]
        self._namespace_is_open = False
        
        self._in_implementation_block = False
        self._current_namespace_str = ""
        self._current_class_members = {}
        self._control_flow_depth = 0

        # [新增] 用于收集当前 implement 块中的方法，以便生成反射表
        # 格式:List[Tuple[func_name, List[param_type]]]
        self._current_impl_methods = []

    # --- 辅助函数 ---
    def _enter_scope(self):
        self._scope_stack.append({})

    def _exit_scope(self):
        if len(self._scope_stack) > 1:
            self._scope_stack.pop()

    def _add_variable(self, CH_name, metadata):
        metadata['state'] = 'Alive'
        metadata['def_depth'] = self._control_flow_depth
        self._scope_stack[-1][CH_name] = metadata

    def _find_variable(self, CH_name):
        for scope in reversed(self._scope_stack):
            if CH_name in scope:
                return scope[CH_name]
        return None

    def _safe_iterate_statements(self, statement_ctx_or_list):
        if not statement_ctx_or_list: return []
        if isinstance(statement_ctx_or_list, list): return statement_ctx_or_list
        return [statement_ctx_or_list]

    def _CH_to_cpp_type(self, CH_type_name):
        # 基础类型映射
        if CH_type_name == "bool": return "bool"
        if CH_type_name == "i32": return "int32_t"
        if CH_type_name == "f32": return "float"
        if CH_type_name == "string": return "std::string" # 简写
        if CH_type_name == "wstring": return "std::wstring"
        if CH_type_name == "vector": return "std::vector"
        
        # [新增] 动态类型映射
        if CH_type_name == "dyn": return "CHObject*"

        # 智能指针
        if CH_type_name == "unique": return "std::unique_ptr"
        if CH_type_name == "shared": return "std::shared_ptr"
        if CH_type_name == "weak": return "std::weak_ptr"
        
        return CH_type_name

    # --- 核心代码生成：动态反射胶水 ---
    def _generate_dynamic_glue_code(self):
        """
        为 @dynamic 类生成 findMethodImpl 函数
        """
        class_name = self._current_class_name
        
        # 函数签名
        code = f"\n// --- CH Runtime Glue Code for {class_name} ---\n"
        code += f"CHObject::MethodTrampoline {class_name}::findMethodImpl(SelectorID sel) {{\n"
        
        # 遍历收集到的所有方法
        for func_name, param_types in self._current_impl_methods:
            # 生成选择子匹配: if (sel == _SEL("funcName"))
            code += f"{INDENT}if (sel == _SEL(\"{func_name}\")) {{\n"
            
            # 生成蹦床 Lambda
            code += f"{INDENT}{INDENT}return [this](void* inst, std::vector<std::any>& args) -> std::any {{\n"
            
            # 1. 恢复 this 指针
            code += f"{INDENT}{INDENT}{INDENT}{class_name}* self = static_cast<{class_name}*>(inst);\n"
            
            # 2. 检查参数数量
            # code += f"{INDENT}{INDENT}{INDENT}if (args.size() < {len(param_types)}) return {{}};\n"
            
            # 3. 解包参数 (Unboxing)
            call_args = []
            for i, p_type in enumerate(param_types):
                # 生成 std::any_cast<Type>(args[i])
                call_args.append(f"std::any_cast<{p_type}>(args[{i}])")
            
            call_args_str = ", ".join(call_args)
            
            # 4. 调用真函数
            code += f"{INDENT}{INDENT}{INDENT}self->{func_name}({call_args_str});\n"
            code += f"{INDENT}{INDENT}{INDENT}return {{}};\n" # 暂时假设所有动态方法返回 void 或忽略返回值
            
            code += f"{INDENT}{INDENT}}};\n" # End Lambda
            code += f"{INDENT}}}\n" # End If
            
        # 递归查父类 (这里硬编码 CHObject，实际应该查 base class)
        # 但由于所有 dyn 都是 CHObject*，查基类是安全的兜底
        code += f"{INDENT}return CHObject::findMethodImpl(sel);\n"
        code += "}\n"
        return code

    # --- Visitors ---

    def visitProgram(self, ctx: CHParser.ProgramContext):
        all_code = ""
        for child in ctx.children:
            if isinstance(child, TerminalNodeImpl):
                if child.getSymbol().type == CHParser.CPP_DIRECTIVE:
                    all_code += self.visit(child)
                continue
            elif child:
                all_code += self.visit(child)
        
        if self._namespace_is_open:
            raise Exception("Namespace not closed.")
        return all_code.strip()

    def visitImportDirective(self, ctx: CHParser.ImportDirectiveContext):
        # ... (保持原有逻辑)
        path_text = ""
        is_system = False
        if ctx.pathStr:
            path_text = ctx.pathStr.text
        else:
            path_text = f"<{ctx.pathSeq.getText()}>"
            is_system = True
            
        if not is_system and self.import_loader_callback:
            self.import_loader_callback(path_text[1:-1])

        if is_system: return f"#include {path_text}\n"
        
        path_content = path_text[1:-1]
        if path_content.startswith('runtime/'): path_content = path_content.replace('runtime/', '')
        root, ext = os.path.splitext(path_content)
        if not ext: path_content += ".h"
        return f'#include "{path_content}"\n'

    def visitClassDefinition(self, ctx: CHParser.ClassDefinitionContext):
        self._current_class_members = {}
        self._in_class = True
        self._in_struct = False
        class_name = ctx.name.text
        
        inheritance_list = []
        if ctx.base: inheritance_list.append(f"public {ctx.base.text}")
        if ctx.interfaces:
            for name in self.visit(ctx.interfaces).split(','):
                inheritance_list.append(f"public {name.strip()}")
        inheritance_str = (" : " + ", ".join(inheritance_list)) if inheritance_list else ""

        self._current_class_name = class_name
        self._class_sections = {"private": "", "public": ""}

        # [新增] 检查 @dynamic 注解
        is_dynamic = bool(ctx.AT_DYNAMIC())

        if hasattr(ctx, 'classBodyStatement'):
            for child in ctx.classBodyStatement():
                self.visit(child)

        # [新增] 如果是动态类，声明 findMethodImpl 虚函数
        if is_dynamic:
            self._class_sections["public"] += f"{INDENT}virtual MethodTrampoline findMethodImpl(SelectorID sel) override;\n"

        final_body = ""
        if self._class_sections["public"]: final_body += f"\npublic:\n{self._class_sections['public']}"
        if self._class_sections["private"]: final_body += f"\nprivate:\n{self._class_sections['private']}"

        self._in_class = False
        self._current_class_name = None
        return f"\nclass {class_name}{inheritance_str} {{\n{final_body.strip()}\n}};\n"

    def visitImplementationBlock(self, ctx: CHParser.ImplementationBlockContext):
        self._in_implementation_block = True
        self._current_class_name = ctx.name.text
        self._in_class = True
        
        # [新增] 初始化方法列表
        self._current_impl_methods = []
        is_dynamic = bool(ctx.AT_DYNAMIC())

        body_code = ""
        for child in ctx.children:
            if isinstance(child, (CHParser.MethodDefinitionContext,
                                  CHParser.InitDefinitionContext,
                                  CHParser.DeinitBlockContext)):
                body_code += self.visit(child)

        # [新增] 生成反射胶水代码
        if is_dynamic:
            body_code += self._generate_dynamic_glue_code()

        self._in_implementation_block = False
        self._current_class_name = None
        self._in_class = False
        self._current_impl_methods = [] # 清理

        return body_code

    def visitMethodDefinition(self, ctx: CHParser.MethodDefinitionContext):
        self._in_class_method = True
        self._enter_scope()
        
        # 添加 this
        self._add_variable("this", {"cpp_name": "this", "cpp_type": f"{self._current_class_name}*"})
        
        # [新增] 收集方法信息 (如果在 implement 块中)
        if self._in_implementation_block:
            func_name = ctx.name.text
            params = []
            if ctx.parameters():
                for p in ctx.parameters().parameter():
                    # 获取参数的 C++ 类型字符串 (e.g. "std::string")
                    p_type = self.visit(p.typeName)
                    params.append(p_type)
            self._current_impl_methods.append((func_name, params))

        func_name = ctx.name.text
        params_code = self.visit(ctx.parameters()) if ctx.parameters() else ""
        body_code = "".join(self.visit(s) for s in self._safe_iterate_statements(ctx.statement()))
        return_type = self.visit(ctx.returnType) if ctx.returnType else "void"

        self._exit_scope()
        self._in_class_method = False

        if self._in_implementation_block:
            return f"\n{return_type} {self._current_class_name}::{func_name}({params_code}) {{\n{body_code}}}\n"
        else:
            # 内联/类定义中的处理
            access = getattr(ctx, '_CH_access', 'private')
            if self._in_struct: access = 'public'
            # ... 省略 static/virtual 处理，假设非动态方法默认处理 ...
            self._class_sections[access] += f"\n{INDENT}{return_type} {func_name}({params_code}) {{\n{body_code}{INDENT}}}\n"
            return ""

    def visitSimpleExpression(self, ctx: CHParser.SimpleExpressionContext):
        # 1. Primary
        current_code = ""
        if ctx.primary(): current_code = self.visit(ctx.primary())
        elif ctx.functionCallExpression(): current_code = self.visit(ctx.functionCallExpression())
        else: return ""

        # 2. Suffixes
        child_nodes = ctx.children
        i = 1
        while i < len(child_nodes):
            node = child_nodes[i]
            token_type = node.getSymbol().type

            # A. . / -> / ::
            if token_type in [CHParser.DOT, CHParser.ARROW, CHParser.COLON_COLON]:
                op = node.getText() # ., ->, ::
                i += 1
                ident = child_nodes[i].getText()
                
                # 内置类型映射检查 (e.g. string::npos -> std::string::npos)
                # 这里不仅查变量名，也查类型名
                var_info = self._find_variable(ident)
                if var_info: ident = var_info["cpp_name"]
                else: ident = self._CH_to_cpp_type(ident)

                current_code += f"{op}{ident}"
                
                # Template <T>
                i += 1
                if i < len(child_nodes) and child_nodes[i].getSymbol().type == CHParser.LT:
                    i += 1 # <
                    if i < len(child_nodes) and isinstance(child_nodes[i], CHParser.TypeListContext):
                        current_code += f"<{self.visit(child_nodes[i])}>"
                        i += 1
                    i += 1 # >
                
                # Call (...)
                if i < len(child_nodes) and child_nodes[i].getSymbol().type == CHParser.LPAREN:
                    i += 1 # (
                    args = ""
                    if i < len(child_nodes) and isinstance(child_nodes[i], CHParser.ExpressionListContext):
                        args = self.visit(child_nodes[i])
                        i += 1
                    i += 1 # )
                    current_code += f"({args})"

            # B. Array [ ]
            elif token_type == CHParser.LBRACK:
                i += 1 
                idx = self.visit(child_nodes[i])
                i += 2 # expr + ]
                current_code += f"[{idx}]"

            # C. [核心新增] 动态调用 ~> 
            elif token_type == CHParser.TILDE_ARROW:
                i += 1 # skip ~>
                
                method_name = child_nodes[i].getText()
                i += 1
                
                args_code = ""
                if i < len(child_nodes) and child_nodes[i].getSymbol().type == CHParser.LPAREN:
                    i += 1 # (
                    if i < len(child_nodes) and isinstance(child_nodes[i], CHParser.ExpressionListContext):
                        # 特殊处理：参数装箱
                        boxed_args = []
                        for expr in child_nodes[i].expression():
                            val = self.visit(expr)
                            # 字符串字面量处理: "abc" -> std::string("abc")
                            # 否则 std::any 会存 const char*，导致解包 std::string 失败
                            if val.startswith('"') and val.endswith('"'):
                                val = f"std::string({val})"
                            boxed_args.append(val)
                        args_code = ", ".join(boxed_args)
                        i += 1
                    i += 1 # )
                
                # 生成 msgSend 代码
                current_code = f"{current_code}->msgSend(_SEL(\"{method_name}\"), {{ {args_code} }})"

            else:
                i += 1
        
        return current_code

    # --- 其他必要的基础 Visitor 实现 ---
    
    def visitFunctionCallExpression(self, ctx: CHParser.FunctionCallExpressionContext):
        name = ctx.funcName.text
        # 类型映射 (e.g. string() -> std::string())
        cpp_name = self._CH_to_cpp_type(name)
        
        args = ""
        if ctx.expressionList():
            args = ", ".join([self.visit(e) for e in ctx.expressionList().expression()])
        return f"{cpp_name}({args})"

    def visitPrimary(self, ctx: CHParser.PrimaryContext):
        if ctx.NEW():
            type_name = self.visit(ctx.baseType())
            args = self.visit(ctx.expressionList()) if ctx.expressionList() else ""
            return f"new {type_name}({args})"
        if ctx.literal(): return self.visit(ctx.literal())
        if ctx.IDENTIFIER():
            text = ctx.IDENTIFIER().getText()
            var = self._find_variable(text)
            if var: return var["cpp_name"]
            # 类型映射 (e.g. string::npos)
            mapped = self._CH_to_cpp_type(text)
            return mapped
        if ctx.THIS(): return "this"
        if ctx.LPAREN(): return f"({self.visit(ctx.expression())})"
        # ... @make 等其他处理 ...
        return ""

    def visitLiteral(self, ctx: CHParser.LiteralContext):
        return ctx.getText()

    def visitTypeSpecifier(self, ctx: CHParser.TypeSpecifierContext):
        if ctx.baseType():
            base = self.visit(ctx.baseType())
            if ctx.LT():
                args = self.visit(ctx.typeList(0))
                return f"{base}<{args}>"
            return base
        return ""

    def visitBaseType(self, ctx: CHParser.BaseTypeContext):
        return self._CH_to_cpp_type(ctx.getText().replace('.', '::'))

    # ... (其余 VariableDeclaration, Assignment, Block 等保持标准实现，略去以节省篇幅) ...
    # 请保留您现有的其他标准 visit 方法，特别是 visitVariableDeclaration 和 visitStatement
    
    # [补全] 必须包含 visitVariableDeclaration 否则变量无法定义
    def visitVariableDeclaration(self, ctx: CHParser.VariableDeclarationContext):
        is_extern = bool(ctx.EXTERN())
        extern_prefix = "extern " if is_extern else ""
        
        var_name = ctx.name.text
        base_type = self.visit(ctx.typeName) if ctx.typeName else "auto"
        
        # 处理指针/引用/数组逻辑 (简化版)
        is_ptr = base_type.endswith("*") or base_type == "CHObject*" # dyn
        
        val = ""
        if ctx.expression():
            val = f" = {self.visit(ctx.expression())}"
        elif is_ptr and base_type != "auto":
            val = " = nullptr"

        self._add_variable(var_name, {"cpp_name": var_name, "cpp_type": base_type})
        
        # 判断是否在类中
        if (self._in_class or self._in_struct) and not self._in_class_method:
            access = getattr(ctx, '_CH_access', 'private')
            self._class_sections[access] += f"{INDENT}{base_type} {var_name}{val};\n"
            return ""
            
        return f"{INDENT}{extern_prefix}{base_type} {var_name}{val};\n"

    def visitStatement(self, ctx: CHParser.StatementContext):
        if ctx.expression(): return f"{INDENT}{self.visit(ctx.expression())};\n"
        if ctx.variableDeclaration(): return self.visit(ctx.variableDeclaration())
        if ctx.returnStatement(): 
            val = self.visit(ctx.returnStatement().expression()) if ctx.returnStatement().expression() else ""
            return f"{INDENT}return {val};\n"
        return ""