// -----------------------------------------------------------------------------
// Chrono Parser (ChronoParser.g4) - [已升级: 支持泛型]
// -----------------------------------------------------------------------------
parser grammar ChronoParser;
options { tokenVocab = ChronoLexer; }

// --- [ 1. 新增: 递归泛型规则 ] ---
// typeSpecifier 现在是 'baseType' 加上可选的 'typeList'
typeSpecifier
    : baseType (LBRACK typeList RBRACK)? // (例如 'std.vector' '[' 'i32' ']')
    ;

// baseType 是带点号的名称 (例如 'std.vector' 或 '$String')
baseType
    : IDENTIFIER (DOT IDENTIFIER)*
    ;

// typeList 是 'typeSpecifier' 的逗号分隔列表
// (这允许 'map[string, vector[i32]]')
typeList
    : typeSpecifier (COMMA typeSpecifier)*
    ;


// --- Top Level Rules ---
program : topLevelStatement+ EOF ;

topLevelStatement
    : importDirective
    | cppBlock
    | classDefinition
    | functionDefinition
    ;
    
accessModifier : PUBLIC ;

classBodyStatement
    : (accessModifier)? declaration
    | ( (STATIC (accessModifier)?) 
      | (accessModifier (STATIC)?) 
      ) methodDefinition
    | (accessModifier)? initDefinition
    | methodDefinition 
    | deinitBlock
    | cppBlock
    ;
    
classDefinition : CLASS name=IDENTIFIER (COLON base=IDENTIFIER)?
    LBRACE
        (classBodyStatement)* RBRACE ;

// [修改] methodDefinition 现在使用新的 typeSpecifier
methodDefinition
    : FUNC name=IDENTIFIER LPAREN parameters RPAREN (ARROW returnType=typeSpecifier)? // <-- [修改]
    LBRACE
      statement* RBRACE ;

initDefinition
    : INIT LPAREN parameters RPAREN LBRACE statement* RBRACE ;

deinitBlock : DEINIT LBRACE statement* RBRACE ;

importDirective
    : IMPORT path=(STRING_LITERERAL | INCLUDE_PATH) (AS alias=IDENTIFIER)? SEMIC_TOKEN ;

// [修改] functionDefinition 现在使用新的 typeSpecifier
functionDefinition
    : (STATIC)?
    FUNC name=IDENTIFIER LPAREN parameters RPAREN (ARROW returnType=typeSpecifier)? // <-- [修改]
      LBRACE 
          statement* RBRACE ;

parameters : (parameter (COMMA parameter)*)? ;

// --- [ 2. 已修改: 'parameter' 规则 ] ---
// 'typeName' 现在使用新的 'typeSpecifier' 规则
parameter 
    : name=IDENTIFIER COLON typeName=typeSpecifier 
    ;

// --- [ 3. 已修改: 'declaration' 规则 ] ---
// 'typeName' 现在使用新的 'typeSpecifier' 规则
declaration 
    : LET variableName=IDENTIFIER COLON typeName=typeSpecifier (ASSIGN expression)? SEMIC_TOKEN 
    ;

cppBlock : AT_CPP CPP_BODY* AT_END ;

returnStatement : RETURN expression SEMIC_TOKEN ;

assignment : assignableExpression ASSIGN expression SEMIC_TOKEN ;

assignableExpression
    : (IDENTIFIER | THIS) (DOT IDENTIFIER)*
    ;

// --- Flow Control (使用重构后的新规则) ---
ifStatement
    : IF LPAREN expression RPAREN if_block=ifBlock
      ( ELSE 
        ( else_if=ifStatement 
        | else_block=elseBlock
        )
      )?
    ;

ifBlock : LBRACE statement* RBRACE ;
elseBlock : LBRACE statement* RBRACE ;

whileStatement
    : WHILE LPAREN expression RPAREN LBRACE statement* RBRACE 
    ;

// --- Composite Rule ---
statement : declaration
          | assignment
          | returnStatement
          | expression SEMIC_TOKEN 
          | cppBlock
          | ifStatement
          | whileStatement
          | deleteStatement
          ;

deleteStatement : DELETE expression SEMIC_TOKEN ;

// --- Expressions ---
expression
    : simpleExpression (
        (EQ | NEQ | LT | GT | LTE | GTE | PLUS | MINUS | STAR | SLASH) simpleExpression
      )?
    ;

simpleExpression
    : primary ( DOT IDENTIFIER (LPAREN expressionList? RPAREN)? )* | functionCallExpression 
    ;

// [修改] primary (NEW) 现在使用 baseType
primary
    : NEW baseType LPAREN expressionList? RPAREN // <-- [修改] (例如 new std.vector[i32]())
    | literal
    | IDENTIFIER
    | THIS
    | LPAREN expression RPAREN
    ;

functionCallExpression : name=IDENTIFIER LPAREN expressionList? RPAREN ;
expressionList : expression (COMMA expression)* ;
literal : INTEGER_LITERAL | STRING_LITERAL | BOOL_LITERAL ;